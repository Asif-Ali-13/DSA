----------------------------------------------------------------------------------------

problem statement: 
There is an integer array nums sorted in ascending order (with "distinct" values).
                                                                ^^^^^^^^
Given the array nums after the possible rotation and an integer target, 
return the index of target if it is in nums, or -1 if it is not in nums.

follow up: 
"not" necessarily with "distinct" values.

----------------------------------------------------------------------------------------

approach: 
    1. use binary search 
    2. low = 0, high = n - 1; -> find mid
    3. if nums[mid] == t -> return mid
    4. check if left half is sorted and k is in between
    5. else check for the right half -> sorted and k is in between

----------------------------------------------------------------------------------------

code: 

int l = 0, h = nums.length - 1;
while(l <= h){

    int m = l + (h - l) / 2;
    if(nums[m] == k) return m;

    // edge case when the values are not distinct (for follow up part)
    else if(nums[l] == nums[m] && nums[m] == nums[h]){  
        l += 1;
        h -= 1;
    }

    else if(nums[l] <= nums[m]){
        if(nums[l] <= k && k <= nums[m]) h = m - 1;
        else l = m + 1;
    }
    else {
        if(nums[m] <= k && k <= nums[h]) l = m + 1;
        else h = m - 1;
    }
}
return -1;

----------------------------------------------------------------------------------------

tc: O(log N)
sc: O(1)

----------------------------------------------------------------------------------------
