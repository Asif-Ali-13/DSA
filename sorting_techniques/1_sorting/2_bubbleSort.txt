----------------------------------------------------------------------------------------

approach: 
    1. start with the first element
    2. compare it with the next element
    3. if it is greater than the next then swap it
    4. do it for n-1 times

key points:
    1. loop i (n-1 to 0)
    2. loop j (0 to i-1)
    3. arr[j] > arr[j+1] -> swap

rem: 
    1. at ith iteration, we found out the ith largest element in the array

----------------------------------------------------------------------------------------

code: 

int n = arr.length;
for(int i=n-1; i>=0; i--){

    for(int j=0; j<=i-1; j++){
        if(arr[j] > arr[j+1]){

            int temp = arr[j];
            arr[j] = arr[j+1];
            arr[j+1] = temp;
        }
    }
}

----------------------------------------------------------------------------------------

tc: O(N^2)
sc: O(1)

----------------------------------------------------------------------------------------

we can optimise it in case of sorted array: 
    - if there is no swap in the first iteration then array is already sorted.

code :

int n = arr.length;
for(int i=n-1; i>=0; i--){
    boolean firstSwap = false;

    for(int j=0; j<=i-1; j++){
        if(arr[j] > arr[j+1]){

            int temp = arr[j];
            arr[j] = arr[j+1];
            arr[j+1] = temp;

            firstSwap = true;
        }
    }
    if(!firstSwap) break;
}

----------------------------------------------------------------------------------------