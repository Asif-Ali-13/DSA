----------------------------------------------------------------------------------------

approach: 
    1. divide and merge

key points: 
    1. base case: low >= high
    2. mergeSort(arr, low, mid)
    3. mergeSort(arr, mid+1, high)
    4. merge(arr, low, mid, high)

    merge: 
        1. temp -> arrayList
        2. left = low, right = mid+1
        3. compare and fill temp as sorted
        4. fill back the og
    
----------------------------------------------------------------------------------------

code: 

merge(arr[], low, mid, high)
    ArrayList<Integer> temp = new ArrayList();
    int left = low, right = mid+1;

    while(left <= mid && right <= high){
        
        if(arr[left] <= arr[right]) temp.add(arr[left++]);
        else temp.add(arr[right++]);
    }

    while(left <= mid) temp.add(arr[left++]);
    while(right <= high) temp.add(arr[right++]);

    for(int i=low; i<=high; i++) arr[i] = temp.get(i-low);


mergeSort (arr[], low, high)
    if(low >= high) return;
    int mid = (high + low) / 2;
    mergeSort(arr, low, mid);
    mergeSort(arr, mid+1, high);
    merge(arr, low, mid, high);

----------------------------------------------------------------------------------------

tc: O(N*log(N))
sc: O(N)

----------------------------------------------------------------------------------------